<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>minemine</title>
  <subtitle>Write something for my love.</subtitle>
  <link href="https://minemine.cc/atom.xml" rel="self"/>
  <link href="https://minemine.cc"/>
  <updated>2018-11-10T05:13:30.262Z</updated>
  <id>https://minemine.cc</id>
  <author>
      <name>luyilin</name>
      <email>luyilin12@gmail.com</email>
    </author>
  <generator uri="http://github.com/egojump/peco/" version="0.2.2">Peco</generator>
  <entry>
      <title>一名曾经沉迷网络小说的少女的自白</title>
      <link href="https://minemine.cc/2018/11/10/internet-novel"/>
      <id>https://minemine.cc/2018/11/10/internet-novel</id>
      <updated>2018-11-10T05:13:30.262Z</updated>
      <content type="html"><![CDATA[<!--router:internet-novel-->
<!--date:2017.12.01-->
<!--cate:2-->
<h4 id="-2">这篇文章其实不是在为网络小说正名，至少等它不再叫网络小说吧</h4>
<p>在写下这个题目后我第一时间去搜了下什么是网络小说，我才发现我似乎并不清楚什么才是网络小说。这是百度百科网络小说的第一句，</p>
<p><img src="https://i.loli.net/2017/12/01/5a2129fc56935.png" alt="网络小说"></p>
<p>emmmm行吧，那么网络作家呢，<!--more--></p>
<p><img src="https://i.loli.net/2017/12/01/5a212bac991ef.png" alt="网络作家"></p>
<p>这个释义大概是有时效性的，未来仅仅通过传统纸媒来发表作品的作家可能非常之少，那么大部分作家其实都可以叫做网络作家，不过当在网络平台发表作品成为一种常态，在网上发表作品的作家占了绝大多数时，应该不会再有这样一个专门的词语来界定传统作家和网络作家，这个名称可能仅存于这一历史阶段。相信这一天不会太远了。</p>
<p>因此简单地用是否是网络小说来界定我看过的小说们似乎并不科学。忘了之前在哪看过的一句话，艺术有高下之分，但是艺术的形式没有。那么艺术发表的平台有吗（捂脸），想想就觉得很扯吧。</p>
<p>那么网络小说和传统文学的最大区别是什么呢？为什么网络小说会给人一种难登大雅之堂的印象。之前在知乎上看到过相关问题的讨论，有一点我觉得很有道理，他说有一些小说写出来仅仅是为了迎合读者，简单点讲就是为了爽而爽，一个例子是在起点连载的一篇小说阅读量骤降，编辑说我不用看就知道你肯定把女主角写死了，读者是为了高兴才看的，你把主角都写死了谁还看你写的小说啊。难以想象在这样浮躁的环境下作者怎么写出优秀的作品，当然也有很多自来水的作者，如果只是为了迎合读者为了钱而写作，那大概是最无趣的事了。这种小说有一个更确切的名字是爽文，这是一个界线。</p>
<p>我曾经有一段时间沉迷于看这种小说，看女主重生凭着预演未来的能力和种种主角光环过得风生水起，择良婿惩坏人，看各种不符常理的宫斗宅斗情节，时间久了有一个很大的问题。我曾经觉得这些也是文学作品啊，看这些总比什么都不看强，对文学修养写作能力什么的应该也有帮助。事实上是，没有。我根本记不起具体的故事是怎样的，没有曲奇得让我心旌摇荡的情节，更没有让我有强烈震撼的时刻，剧情安排和情绪波动都是很浅层的，读这些小说不怎么需要思考，在看的时候能很快地代入，关掉页面后似乎什么都没有发生过。大部分都是套路和词藻的堆砌，好像我也能写，其实我也写不出233. 更重要的是，我似乎与周围的世界脱节了，整体沉迷于看这些小说占用我很大一部分时间，一目十行地阅读并不适用于其他东西，不管是课本还是其他小说，而且习惯了不怎么动脑的阅读后看其他的东西会有一种吃力感，看了一会儿感觉不到<code v-pre="">爽点</code>就耐不下性子看了，心浮气躁到不行。如果把这些变化归罪于看爽文是件很不负责任的事，主要还是我的问题，通过短暂地霸占大脑让内心不那么空虚，仅仅说明看这些没啥正面影响。</p>
<p>我迄今无法忘记给我的初恋男友推荐一本当时很喜欢的穿越小说后他的反应，我嘴硬反驳却也模糊觉得没啥很值得推荐的地方，以至于很长一段时间里我都羞于承认在看网络小说。我当时隐约感觉到，我说很喜欢可能仅止于当时很喜欢，过了一段时间再想可能觉得自己在犯傻，就如同他当时的心情。所以说喜欢大概是很廉价的东西，仅仅因为感觉到了一丝愉悦，就能觉得哇好喜欢，而遇到了一丝阻碍就能立刻冲淡这种感觉，我把它归结于简单原始又稍纵即逝的多巴胺分泌在作祟。也可能因为我是个很不坚定的人。</p>
<p>还有另一种原因，就是它可能没有那么好，而且一个人的心境是会变的，所谓的喜欢可能仅仅因为当时浅薄的自己。如果你不确定是否喜欢它，或者头脑狂热地认为它好到不行，一个建议是过段时间再读一下吧，看你是否还有想读的冲动，读了是否还会觉得很好。</p>
<p>至于过后不喜欢了就贬低它们，这种行为也是我万万不想做的。</p>
<p>至于那本穿越小说，抱歉没有再看第二遍，因此无法通过时间检验它是否真的值得看。</p>
<p>以上我所说的，可能都是错的。</p>
]]></content>
      <summary type="html"><p>在写下这个题目后我第一时间去搜了下什么是网络小说，我才发现我似乎并不清楚什么才是网络小说。这是百度百科网络小说的第一句，</p>
</summary>
    </entry>
<entry>
      <title>流畅地开发一个 react 组件</title>
      <link href="https://minemine.cc/2018/01/29/create-react-component-like-a-pro"/>
      <id>https://minemine.cc/2018/01/29/create-react-component-like-a-pro</id>
      <updated>2018-01-29T00:00:00.000Z</updated>
      <content type="html"><![CDATA[<p>不知道你有没有用过 <a href="https://github.com/vue-land/create-vue-component">vue-land/create-vue-component</a>，这是一个通过命令行初始化 vue 组件的工具，项目结构简洁，无需配置文件。使用 <a href="https://poi.js.org/">Poi</a> 构建，可以打包你写的组件，构建 demo，内置 jest 测试... 总之用来写 vue 组件非常好用，我已经离不开它了。</p>
<p>最近在写 react，在我想用 react 写点简单的组件骗点 star 的时候也想有这么流畅的开发体验啊 (╯°A°)╯ 所以克隆了这个项目，魔改了一版，现在也能通过命令行初始化一个 react 组件了，基本上是体力活...比较适合我这种笨人...<!--more--><br/></p>
<p>项目名字叫 create-react-component-with-no-config 嗯... 我在 npm 上已经找不到可以用的简洁的名字了 😂</p>
<p>create-vue-component 有的功能都有，就是这么好（no）用（face）</p>
<p>项目地址：<a href="https://github.com/luyilin/create-react-component-with-no-config">https://github.com/luyilin/create-react-component-with-no-config</a></p>
<p>用法：</p>
<h4 id="install">Install</h4>
<div class="pre-wrapper" v-pre="" data-lang="bash"><pre class="language-bash"><code class="language-bash">yarn global add create-react-component-with-no-config</code></pre></div><h4 id="usage">Usage</h4>
<div class="pre-wrapper" v-pre="" data-lang="bash"><pre class="language-bash"><code class="language-bash">create-react-component-with-no-config react-xxx
<span class="token comment"># or</span>
create-react-component react-xxx
<span class="token comment"># or type less</span>
crc react-xxx

<span class="token comment"># you can also create component in place</span>
<span class="token function">mkdir</span> react-xxx <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> react-xxx
crc</code></pre></div><p>项目结构预览：</p>
<p><img src="https://wx3.sinaimg.cn/mw690/a2117cdbly1fnxfc4mh6mj20jq0cddgw.jpg" alt="preview"></p>
<p>用例：<a href="https://github.com/luyilin/react-multipane">https://github.com/luyilin/react-multipane</a></p>
<p>Enjoy!</p>
]]></content>
      <summary type="html"><p>不知道你有没有用过 <a href="https://github.com/vue-land/create-vue-component">vue-land/create-vue-component</a>，这是一个通过命令行初始化 vue 组件的工具，项目结构简洁，无需配置文件。使用 <a href="https://poi.js.org/">Poi</a> 构建，可以打包你写的组件，构建 demo，内置 jest 测试... 总之用来写 vue 组件非常好用，我已经离不开它了。</p>
</summary>
    </entry>
<entry>
      <title>为凉风青叶做的简历生成工具</title>
      <link href="https://minemine.cc/2017/12/06/aoba-resume"/>
      <id>https://minemine.cc/2017/12/06/aoba-resume</id>
      <updated>2017-12-06T00:00:00.000Z</updated>
      <content type="html"><![CDATA[<h4 id=""></h4>
<p>初衷是写一个只需要配置文件不需要 git clone 和 run build 就能生成简历的工具。<br/>
灵感来自 EGOIST 的 <a href="https://github.com/egojump/docup">docup</a> 和 DIYgod 的 <a href="https://github.com/DIYgod/Resume">resume</a>，感谢两位大佬，给大佬们递女装👗（这么看好像 couple hahaha ๑乛◡乛๑</p>
<h4 id="-2">项目地址</h4>
<p>Github: <a href="https://github.com/luyilin/Aoba">https://github.com/luyilin/Aoba</a> <!--more--> <br>
Demo: <a href="https://luyilin.github.io/Aoba/">https://luyilin.github.io/Aoba/</a><br>
英文版简历: <a href="https://luyilin.github.io/Aoba/resume-en">https://luyilin.github.io/Aoba/resume-en</a></p>
<h4 id="-3">使用方法</h4>
<p><a href="https://github.com/luyilin/Aoba#quick-start">https://github.com/luyilin/Aoba#quick-start</a></p>
<h4 id="-4">预览</h4>
<p><img src="https://wx1.sinaimg.cn/mw690/a2117cdbly1fmimehr5z7j21kw20te81.jpg" alt="Aoba's resume"></p>
]]></content>
      <summary type="html"><p>初衷是写一个只需要配置文件不需要 git clone 和 run build 就能生成简历的工具。<br/>
灵感来自 EGOIST 的 <a href="https://github.com/egojump/docup">docup</a> 和 DIYgod 的 <a href="https://github.com/DIYgod/Resume">resume</a>，感谢两位大佬，给大佬们递女装👗（这么看好像 couple hahaha ๑乛◡乛๑</p>
</summary>
    </entry>
<entry>
      <title>旧时光</title>
      <link href="https://minemine.cc/2017/11/28/old-time"/>
      <id>https://minemine.cc/2017/11/28/old-time</id>
      <updated>2017-11-28T00:00:00.000Z</updated>
      <content type="html"><![CDATA[<h4 id="">《你好，旧时光》正在热映，我很喜欢周周和林杨，然而本文和它毫无关系。</h4>
<p>不得不说我是个异常怀旧的人，从前发生的种种总是让我非常留恋，可能是因为经过了记忆的过滤和润色，我总是觉得过去的都挺美好。</p>
<p>就像我某次翻看小学时写的日记，有一页写着我超级超级讨厌 XX，绝对绝对不会忘记这件事的，后面还用粗线画了几个大大的叹号。我当时苦思冥想了好久那天到底发生了什么，如你所知，我什么都想不起来，这件事其实说明了两个挺重要的点，一是我当时觉得很重要或者绝不会忘记的事可能根本不怎么重要；<!--more-->二是我可能不大记仇，或者我总是选择性忽视那些曾让我感觉痛苦或者难堪的事，简单点说，逃避型人格。</p>
<p>其实还有另一层解读，就是所有的事可能都不怎么重要，反正随着时间的流逝记忆会越来越模糊，任何情感都会被慢慢冲淡。这句话挺消极的，尤其在情浓之时。我高中时正处于对知识如饥似渴的时候，哦不要误解了，只是对杂书，有一篇解读长恨歌里唐明皇和杨妃的爱情，“在天愿作比翼鸟，在地愿为连理枝”，作者说恋人其实在非常情浓的时候不会去想以后要怎样怎样，更遑论在天上要怎样在地上要怎样，因为当时深陷爱河无暇顾及其他，抱歉已经忘了原话是怎么讲的了，大致是这个意思。原谅我当时毫无恋爱经验，莫名觉得很有道理，额其实我现在也不太懂，读书的最大好处可能就是可以直接复用前人的经验，至于是不是真的，只能说实践是检验真理的唯一标准…… 嗯，讲这个例子可能能成为佐证，即使是诗里写过的美好爱情，基于种种客观和主观原因都会慢慢变淡，不过这也是自然规律，之后的马嵬坡之变也有了看似合理的一种解释。往前看可能会是件不那么着眼于现在的事，至于我呢，我一直喜欢往后看haha。</p>
<p>奇葩说里有一段很有意思，柏邦妮说如果一个人他心里很苦，那要给他多少甜，才能填满他的苦，马东说你错了，他的苦越多，那么一丝甜就能填满。马东东，谁让你讲实话的。。。在时间的洪流里，我的记忆不可避免地会越来越模糊，可是我一直珍惜当时的经历，我怀念小学的玩伴，初中的高中的挚友，还有我的大学，我希望能一直有所回想，可能是另一种证明我存在过的方式，让我每次想起，都很开心。</p>
<p>之所以写下这些胡言乱语，来源于早上四点的惊醒和心跳如雷，加上之前曾有一次失去意识的可怕的晕倒，让我不得不接受身体变差的事实。可能是因为早上没吃饭引发的低血糖，失去意识前几秒我还在想 WTF 我不会就这样挂掉了吧，特喵的不会上社会新闻吧，这可是我万万不想要的。晕倒前还能想这些足以证明我是一个多么 XX 的人了。</p>
]]></content>
      <summary type="html"><p>不得不说我是个异常怀旧的人，从前发生的种种总是让我非常留恋，可能是因为经过了记忆的过滤和润色，我总是觉得过去的都挺美好。</p>
</summary>
    </entry>
<entry>
      <title>使用 vue2.0 实现一个简洁的分页组件</title>
      <link href="https://minemine.cc/2017/04/19/vue-pagination"/>
      <id>https://minemine.cc/2017/04/19/vue-pagination</id>
      <updated>2017-04-19T00:00:00.000Z</updated>
      <content type="html"><![CDATA[<p>分页效果预览：</p>
<ul>
<li><a href="https://luyilin.github.io/Minemine-pagination/dist/index.html">在线 demo</a></li>
<li><a href="https://github.com/luyilin/Minemine-pagination">github 地址</a></li>
<li>分页效果截图<img src="https://ooo.0o0.ooo/2017/04/19/58f7246807888.png" alt="messagedboard"></li>
</ul>
<h3 id="">前言</h3>
<blockquote>
<ol>
<li>使用 vue-cli 初始化项目 <!--more--></li>
<li>使用 vuex 管理数据</li>
<li>node v6.9.2，npm v3.10.9</li>
</ol>
</blockquote>
<h3 id="-2">分页原理</h3>
<p>实现分页主要依靠两个参数，偏移量（offset）、限制数（limit）。点击分页发送 Ajax 请求，将这两个参数传给后端，后端从数据库筛选出对应的数据返回给前端，前端将获取到的数据添加到页面中，分页组件根据偏移量和限制数显示对应的页码，这是一个简单地实现分页的思路。</p>
<h3 id="-3">分页类型</h3>
<p>分页一般分为两种类型，一种经常用于移动端的滚动加载，或是一个按钮点击即可加载更多。这种分页实现起来比较简单，前端仅需定义一个 offset 变量，每次 ajax 请求时 offset += limit，然后将获取到的内容 append 上去即可。
另一种是显示总页数、当前页数、上一页、下一页按钮，且页数较多时将中间页数用省略号表示。这种分页实现起来稍微复杂一点，但用户体验更好，本文讨论的就是如何使用 vue 实现这样的分页组件。</p>
<h3 id="-4">分页组件</h3>
<p>创建 pagination.vue 文件。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class=""><template>
    <div class="page-wrap">
      <ul v-show="prePage" class="li-page" v-tap="{methods: goPrePage}">上一页</ul>
      <ul>
        <li v-for="i in showPageBtn" :class="{active: i === currentPage, pointer: i, hover: i && i !== currentPage}"
            v-tap="{methods: goPage, i: i}">
          <a v-if="i" class="notPointer">{{i}}</a>
          <a v-else>···</a>
        </li>
      </ul>
      <ul v-show="nextPage" class="li-page" v-tap="{methods: goNextPage}">下一页</ul>
    </div>
</template></code></pre></div><p>组件的作用域是独立的，父组件通信通过 props 向其传递数据，分页组件通过 $emit 触发在父组件定义的事件实现和父组件的通信，因此预设从父组件获取到需显示的总数 num 为 30 , limit 为 5，当然你也可以随意设置这两个值～</p>
<pre><code>```
let that
export default{
    data(){
      that = this
      return{
        num: 30,
        limit: 5
      }
    }
}
```
</code></pre>
<p>计算几个变量，在这里可以使用 vue 的计算属性 computed
总页数 totalPage 应该等于需显示的总数除以每页显示的个数，并向上取整，这个很好理解。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">computed: {
      totalPage() {
        return Math.ceil(that.num / that.limit)
      }
    }</code></pre></div><p>偏移量 offset，因为点击上下页、制定页码均会改变 offset 变量，父组件也需要用到这个变量发送 ajax 请求，因此使用 vuex 存储 offset。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">// pagination.vue
    computed: {
      offset() {
          return that.$store.state.offset
      }
    }</code></pre></div><p>当前页面 currentPage，当前页面是比较重要的一个变量，显示用户当前所处页数，已知偏移量和每页显示数量可以得出当前页面是二者的余数向上取整，因为页数不从0开始，因此</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">computed: {
      currentPage() {
        return Math.ceil(that.offset / that.limit) + 1
      }
    }</code></pre></div><p>是否显示上一页按钮 prePage，因为在首页的时候偏移量为0，因此只要偏移量不等于0则当前页面肯定不在第一页，则显示上一页按钮，并且 num 不等于 0。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">coumputed: {
      prePage() {
        return that.offset !== 0 && that.num
      }
    }</code></pre></div><p>是否显示下一页按钮 nextPage，这个也很好理解，只要偏移量和每页显示的个数相加小于需显示的总数，则显示下一页按钮，并且 num 不等于 0。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">computed: {
      nextPage() {
        return (that.offset + that.limit < that.num) && that.num
      }
    }</code></pre></div><p>页码计算 showPageBtn，页码计算是这个分页组件的核心内容，基本思路是当总页数不大于5时，显示全部页码；当总页数大于5时，始终显示首尾页码，当当前页码距首页小于2时，显示前三页页码和省略号；当当前页码距尾页小于2时，显示后三页页码，当当前页码距首页等于2时，显示前四页页码和省略号；当当前页码距尾页等于2时，显示后四页页码和省略号；当当前页码距首页大于3且距尾页大于3时，显示当前页码和当前页码的前一页和后一页，两边各有一个省略号；在这里我们使用0代表省略号</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">computed: {
      showPageBtn() {
          let pageNum = that.totalPage,
              index = that.currentPage,
              arr = []
          if (pageNum <= 5) {
            for(let i = 1; i <= pageNum; i++) {
              arr.push(i)
            }
            return arr
          }
          if (index <= 2) return [1,2,3,0,pageNum]
          if (index >= pageNum -1) return [1,0, pageNum -2, pageNum -1, pageNum]
          if (index === 3) return [1,2,3,4,0,pageNum]
          if (index === pageNum -2) return [1,0, pageNum-3, pageNum-2, pageNum-1, pageNum]
          return [1,0, index-1, index, index + 1, 0, pageNum]
        }
    }</code></pre></div><p>跳转事件，分别点击上一页、下一页和指定页码。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">methods: {
      goPage(params) {
        if (params.i === 0 || params.i === that.currentPage) return
        that.$store.commit('GO_PAGE', (params.i-1) * that.limit)
        that.$emit('getNew')
      },
      goPrePage() {
        that.$store.commit('PRE_PAGE', that.limit)
        that.$emit('getNew')
      },
      goNextPage() {
        that.$store.commit('NEXT_PAGE', that.limit)
        that.$emit('getNew')
      }
    }</code></pre></div><h3 id="vuex">vuex 部分</h3>
<p>在此介绍一下 vuex 部分的实现，学习了二哲大大的 vuex 部分的结构。在 src 目录下（和 components 目录平级），新建 store 目录，其中 index.js 文件传入 mutation，初始化 vuex；</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">// vuex store/index.js
  import Vue from 'vue'
  import Vuex from 'vuex'
  import mutations from './mutations'
  
  Vue.use(Vuex);
  
  const state = {
    offset: 0
  };
  
  export default new Vuex.Store({
    state,
    mutations
  })</code></pre></div><p>mutation-types.js 记录所有的事件名，其实这个文件最大的好处是能让我们更直观地管理所有的 vuex 方法，它的优点会在项目复杂后凸显出来，项目复杂时我们可能会使用 vuex 存储很多数据、定义很多方法，这时 mutation-types.js 就能更好更直观地管理这些方法。这也是一种设计理念嘛，有利于后期维护。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">// mutation-types.js
    export const PRE_PAGE = 'PRE_PAGE'
    export const NEXT_PAGE = 'NEXT_PAGE'
    export const GO_PAGE = 'GO_PAGE'</code></pre></div><p>mutation.js 这是 vuex 的核心文件，注册了实现的所有事件，我们定义了点击上一页、下一页和跳转到指定页面的方法。</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">// mutation.js
  import * as types from './mutation-types'

  export default {
    // 分页 上一页
    [types.PRE_PAGE] (state, offset) {
      state.offset -= offset
    },
    // 分页 下一页
    [types.NEXT_PAGE] (state, offset) {
      state.offset += offset
    },
    // 分页 跳转到指定页码
    [types.GO_PAGE] (state, offset) {
      state.offset = offset
    }
  };</code></pre></div><h3 id="how-to-run">how to run</h3>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">$ npm install 

$ npm run dev

// 访问 http://localhost:8088/index.html</code></pre></div><p>最后打个小广告🎣 ๑乛◡乛๑</p>
<p>我的个人网站：<a href="https://minemine.cc/">https://minemine.cc/</a></p>
<p>github 地址：<a href="https://github.com/luyilin">https://github.com/luyilin</a></p>
]]></content>
      <summary type="html"><p>分页效果预览：</p>
</summary>
    </entry>
<entry>
      <title>记在小本本上的 git 操作</title>
      <link href="https://minemine.cc/2017/01/29/git"/>
      <id>https://minemine.cc/2017/01/29/git</id>
      <updated>2017-01-29T00:00:00.000Z</updated>
      <content type="html"><![CDATA[<p>标签： git</p>
<p>查看 git 配置信息</p>
<div class="pre-wrapper" v-pre="" data-lang="git"><pre class="language-git"><code class="language-git"><span class="token command">$ git config<span class="token parameter"> --list</span></span>
or
<span class="token command">$ git config<span class="token parameter"> -l</span></span></code></pre></div><p>设置 git 配置信息 <!--more--></p>
<ul>
<li>全局设置</li>
</ul>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> config --global user.name <span class="token string">"{{userName}}"</span>
$ <span class="token function">git</span> config --global user.email <span class="token string">"{{userEmail}}"</span></code></pre></div><ul>
<li>修改当前项目的 git 配置信息</li>
</ul>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">ls</span> -a
$ <span class="token function">cd</span> .git/
$ <span class="token function">vi</span> config
add
<span class="token punctuation">[</span>user<span class="token punctuation">]</span>
   name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>userName<span class="token punctuation">}</span><span class="token punctuation">}</span>
   email <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>userEmail<span class="token punctuation">}</span><span class="token punctuation">}</span>

or
$ <span class="token function">git</span> config user.name <span class="token string">"{{userName}}"</span>
$ <span class="token function">git</span> config user.email <span class="token string">"{{userEmail}}"</span></code></pre></div><p>查看分支</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> branch 查看本地分支
$ <span class="token function">git</span> branch -r 查看远程分支
$ <span class="token function">git</span> branch -a 查看所有分支</code></pre></div><p>创建一个新分支</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> checkout -b <span class="token punctuation">{</span><span class="token punctuation">{</span>branch<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></div><p>切换分支</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> checkout <span class="token punctuation">{</span><span class="token punctuation">{</span>branch<span class="token punctuation">}</span><span class="token punctuation">}</span>

$ <span class="token function">git</span> checkout -b <span class="token punctuation">{</span><span class="token punctuation">{</span>remoteBranch<span class="token punctuation">}</span><span class="token punctuation">}</span> origin/<span class="token punctuation">{</span><span class="token punctuation">{</span>remoteBranch<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></div><p>删除分支</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> branch -D <span class="token punctuation">{</span><span class="token punctuation">{</span>loaclBranch<span class="token punctuation">}</span><span class="token punctuation">}</span>
$ <span class="token function">git</span> push --delete origin <span class="token punctuation">{</span><span class="token punctuation">{</span>remoteBranch<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></div><p>合并分支</p>
<div class="pre-wrapper" v-pre="" data-lang=""><pre class=""><code class="">$ git merge {{branch}} 将 branch 与当前分支合并</code></pre></div><p>储藏修改</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> stash 当你想切换到其他分支又不想提交现在修改的东西时，当你在修改好前想 <span class="token function">git</span> pull 时，用 <span class="token function">git</span> stash 来得到一个干净的工作目录

$ <span class="token function">git</span> stash save <span class="token string">''</span> 给你的 stash 取个名字

$ <span class="token function">git</span> stash pop 重新应用储藏内容

$ <span class="token function">git</span> stash list 查看现有储藏列表

$ <span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span>number<span class="token punctuation">}</span> 应用某次储藏，但未从栈上移除，需继续 <span class="token function">git</span> stash drop stash@<span class="token punctuation">{</span>number<span class="token punctuation">}</span> <span class="token punctuation">(</span>I like pop<span class="token operator">!</span></code></pre></div><p>查看提交历史</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> log

$ <span class="token function">git</span> log -p  查看每次提交的内容差异

$ <span class="token function">git</span> log -p -2 显示最近的两次更新</code></pre></div><p>查看 commit head message</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> reflog</code></pre></div><p>打 tag</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> tag <span class="token punctuation">{</span><span class="token punctuation">{</span>tagName<span class="token punctuation">}</span><span class="token punctuation">}</span>
$ <span class="token function">git</span> push origin <span class="token punctuation">{</span><span class="token punctuation">{</span>tagName<span class="token punctuation">}</span><span class="token punctuation">}</span>
or
$ <span class="token function">git</span> push --tags</code></pre></div><p>删除 tag</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> tag -d <span class="token punctuation">{</span><span class="token punctuation">{</span>localTag<span class="token punctuation">}</span><span class="token punctuation">}</span>

$ <span class="token function">git</span> tag -d <span class="token punctuation">{</span><span class="token punctuation">{</span>remoteTag<span class="token punctuation">}</span><span class="token punctuation">}</span>
$ <span class="token function">git</span> push origin :refs/tags/<span class="token punctuation">{</span><span class="token punctuation">{</span>remoteTag<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></div><p>给一个历史提交添加 tag</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">// Set the HEAD to the old commit that we want to tag
$ <span class="token function">git</span> checkout <span class="token punctuation">{</span><span class="token punctuation">{</span>leading 7 chars of commit<span class="token punctuation">}</span><span class="token punctuation">}</span>

// temporarily <span class="token keyword">set</span> the <span class="token function">date</span> to the <span class="token function">date</span> of the HEAD commit, and add the tag
$ GIT_COMMITTER_DATE<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">git</span> show --format<span class="token operator">=</span>%aD <span class="token operator">|</span> <span class="token function">head</span> -1<span class="token variable">)</span></span>"</span> <span class="token function">git</span> tag -a <span class="token punctuation">{</span><span class="token punctuation">{</span>tag<span class="token punctuation">}</span><span class="token punctuation">}</span> -m <span class="token string">"{{commit message}}"</span>

// <span class="token keyword">set</span> HEAD back to whatever you want it to be
$ <span class="token function">git</span> checkout master

$ <span class="token function">git</span> push --tags</code></pre></div><p>push 后发现没加 .gitignore，删除本地及远程的冗余提交</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> <span class="token function">rm</span> -r --cached <span class="token keyword">.</span>
$ <span class="token function">git</span> add <span class="token keyword">.</span>
$ <span class="token function">git</span> commit -m <span class="token string">"{{commit message}}"</span>
$ <span class="token function">git</span> push</code></pre></div><p>修改已经 commit 的邮箱和用户名</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">// get the commit we want to modify
$ <span class="token function">git</span> log

// go to the commit
$ <span class="token function">git</span> reset --soft <span class="token punctuation">{</span><span class="token punctuation">{</span>commitId<span class="token punctuation">}</span><span class="token punctuation">}</span>

$ <span class="token function">git</span> commit --amend --author<span class="token operator">=</span><span class="token string">'{{userName}}&lt;{{userEmail}}>'</span>
$ <span class="token function">git</span> push</code></pre></div><p>修改已经 push 的 commit 的邮箱和用户名</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">// clone a new repo
<span class="token function">git</span> clone --bare https://github.com/user/repo.git
<span class="token function">cd</span> repo.git</code></pre></div><div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">// copy the script below and modify the variables: OLD_EMAIL, CORRECT_NAME, CORRECT_EMAIL

<span class="token comment">#! /bin/sh</span>

<span class="token function">git</span> filter-branch --env-filter <span class="token string">'

OLD_EMAIL=""
CORRECT_NAME="Your Correct Name"
CORRECT_EMAIL="your-correct-email@example.com"

if [ "<span class="token variable">$GIT_COMMITTER_EMAIL</span>" = "<span class="token variable">$OLD_EMAIL</span>" ]
then
    export GIT_COMMITTER_NAME="<span class="token variable">$CORRECT_NAME</span>"
    export GIT_COMMITTER_EMAIL="<span class="token variable">$CORRECT_EMAIL</span>"
fi
if [ "<span class="token variable">$GIT_AUTHOR_EMAIL</span>" = "<span class="token variable">$OLD_EMAIL</span>" ]
then
    export GIT_AUTHOR_NAME="<span class="token variable">$CORRECT_NAME</span>"
    export GIT_AUTHOR_EMAIL="<span class="token variable">$CORRECT_EMAIL</span>"
fi
'</span> --tag-name-filter <span class="token function">cat</span> -- --branches --tags</code></pre></div><div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">// <span class="token keyword">then</span> press enter to run the script

// checkout <span class="token keyword">if</span> there any error <span class="token keyword">in</span> new <span class="token function">git</span> and push
$ <span class="token function">git</span> push --force --tags origin <span class="token string">'refs/heads/*'</span>

// delete the temporary clone
$ <span class="token function">cd</span> <span class="token punctuation">..</span>
$ <span class="token function">rm</span> -rf repo.git</code></pre></div><p>修改已经 push 的 commit message</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">方法一:
$ <span class="token function">git</span> commit --amend
$ <span class="token function">git</span> push --force

方法二:
$ <span class="token function">git</span> rebase -i HEAD~n

change the <span class="token variable"><span class="token variable">`</span>pick<span class="token variable">`</span></span> to <span class="token variable"><span class="token variable">`</span>reword<span class="token variable">`</span></span>, <span class="token function">which</span> means edit the commit message

save and <span class="token keyword">exit</span> and <span class="token keyword">then</span> update the commit message as you like and :wq

$ <span class="token function">git</span> push --f</code></pre></div><p>修改已经 push 的提交内容</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell"><span class="token function">git</span> reset --hard <span class="token punctuation">{</span><span class="token punctuation">{</span>commitId<span class="token punctuation">}</span><span class="token punctuation">}</span>

<span class="token function">git</span> add <span class="token keyword">.</span>

<span class="token function">git</span> commit --amend

<span class="token function">git</span> push origin HEAD --force</code></pre></div><p>解决提交前的 conflict，协同工作必备</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">// 先不提交修改的内容直接创建新分支 temp ，若已 commit 则创建新分支后在本分支 reset 到上一个 commit ,再执行 <span class="token function">git</span> pull

$ <span class="token function">git</span> checkout -b temp

$ <span class="token function">git</span> add <span class="token keyword">.</span>

$ <span class="token function">git</span> commit -m <span class="token string">'commit message'</span>

// 此时的master 分支是干净的，无自己的提交
$ <span class="token function">git</span> checkout master

// 拉取远程修改
$ <span class="token function">git</span> pull

// 复制刚刚提交的 commit-id  commit-a, 将自己的提交 cherry-pick 进去
$ <span class="token function">git</span> cherry-pick commit-a

// 如果有冲突 fix it
$ <span class="token function">git</span> add <span class="token keyword">.</span>

$ <span class="token function">git</span> cherry-pick --continue

// <span class="token keyword">then</span> push
$ <span class="token function">git</span> push</code></pre></div><p>git 删除远程仓库的某次错误提交</p>
<div class="pre-wrapper" v-pre="" data-lang="shell"><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> reset --hard HEAD~1

$ <span class="token function">git</span> push --force
// <span class="token function">git</span> push -f

// 强制推送到远程仓库，远程仓库里的错误提交也会消失</code></pre></div><ul>
<li>需注意，其实这种方法仅适用于删除最新的一次提交，如果某次错误提交后又有了一个新的提交，则强制删除错误提交会导致后面的提交也消失，因此需慎用此方法，尤其是在多人协作项目上(°ー°〃)</li>
</ul>
<p>gerrit merge 前执行 git commit --amend 改写上次提交，并将 gerrit 上的 changeid 加入到上次提交的 commit message 下面（上下各空一行），再 git push（还是原来的 commit，不产生新的提交）</p>
<p>bash ctrl＋R 快速查看输入过的命令</p>
<p>git 创建仓库并关联到 github</p>
<ul>
<li>
<p>cd 到项目目录，git init 初始化，使 git 对此项目进行版本控制</p>
</li>
<li>
<p>git add .</p>
</li>
<li>
<p>git commit -m ''</p>
</li>
<li>
<p>在 github 上创建一个新仓库 create a new repository</p>
</li>
<li>
<p>将本地项目关联到建立的新仓库上 <code v-pre="">git remote add origin {{url}}</code></p>
</li>
<li>
<p>运行 <code v-pre="">$ git remote -v</code> 查看 origin 关联</p>
</li>
<li>
<p><code v-pre="">git push -u origin master</code></p>
</li>
<li>
<p>若本地已有代码非空, 则直接<code v-pre="">git remote add origin {{url}}</code></p>
</li>
<li>
<p><code v-pre="">git push -u origin master</code></p>
</li>
<li>
<p>若将一个 git 仓库关联为另一个 git 仓库,则<code v-pre="">ls -a</code> 删除 .git/ 文件夹即可
删除 git 版本控制, 然后再执行 remote</p>
</li>
</ul>
<p>Github Pages 发布静态页面</p>
<ul>
<li>repository-Settings-Github Pages-select a source and save</li>
</ul>
]]></content>
      <summary type="html"><p>标签： git</p>
</summary>
    </entry>
</feed>